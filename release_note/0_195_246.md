# Release Note: v0.195.246

## 同期アーキテクチャの全面リファクタリング — カーソルジャンプ完全解消 & 外部変更のリアルタイム反映

---

## 背景と課題

### これまでの経緯

v0.195.245 以前は、Webview ↔ VSCode Document 間の同期において「フォーカスベースの排他制御」を使用していた。これは commit `8bba05d` で導入された方式で、カーソルジャンプ問題（VSCodeの `onDidChangeTextDocument` の非同期発火に起因）を解決するための最終手段だった。

### フォーカスベース方式の限界

フォーカスベース方式は以下のシンプルなルールで動作していた:

```
Webviewにフォーカスがある間 → onDidChangeTextDocument を完全無視
Webviewからフォーカスが外れたら → 溜まった外部変更を反映
```

これにより5つの課題が残っていた:

| No | 課題 | 詳細 |
| --- | --- | --- |
| 1 | カーソルジャンプの潜在リスク | フォーカスが外れた瞬間に `renderFromMarkdown()` が実行され、`editor.innerHTML` 全置換が発生。フォーカスが戻ると直前のカーソル位置は失われる |
| 2 | 入力中の外部変更によるデータ競合 | 入力中に外部変更が来ても、blur時に一括で全置換されるため、入力中の内容が失われる可能性がある |
| 3 | フォーカス中の外部変更が一切反映されない | ユーザーがエディタにカーソルを置いたまま何も入力していない状態でも、外部変更（git操作、別エディタでの編集、AIツールによる自動編集等）が反映されない。ユーザーはフォーカスを一度外して戻す必要がある |
| 4 | 外部変更反映時のカーソル喪失 | blur → 外部変更反映 → focus と操作した場合、`renderFromMarkdown()` による全置換でカーソル位置が先頭にリセットされる |
| 5 | VSCodeメッセージの表示 | 外部ツールがファイルを直接変更した場合、TextDocumentとファイルの内容が不整合を起こし、「保存されていません」「競合が発生しました」「すでに上書きされています」などのVSCodeメッセージが表示される |

---

## 要件定義

上記の課題を踏まえ、以下の5つの要件を定義した:

| 要件 | 内容 |
| --- | --- |
| **(1)** | 自分が入力中に絶対に `innerHTML` 全置換を発生させない = カーソルジャンプを発生させない |
| **(2)** | (1) の最中に、外部変更は受け入れない |
| **(3)** | (1) 以外については、**フォーカスがあっても**常に外部変更を受け入れる。また、(1) の最中に反映されなかった変更は、(1) でなくなったら反映させる |
| **(4)** | 全置換でも部分置換でも、いずれのケースもカーソルを勝手に飛ばすのはNG |
| **(5)** | 自分の修正でも、外部修正でも「保存されていません」「競合が発生しました」「すでに上書きされています」等のVSCodeメッセージは出さない |

---

## 実装: 3フェーズのリファクタリング

### Phase 1: updateFromMarkdown() — ブロック単位DOM diff + カーソル保存/復元

#### 対象ファイル
- `src/webview/editor.js`

#### 課題
従来の `renderFromMarkdown()` は `editor.innerHTML = html` による全置換を行っていた。これがカーソル喪失の直接的な原因。

#### 解決策
新しい `updateFromMarkdown()` 関数を実装。外部変更の反映時にのみ使用する（初期描画やモード切替は従来通り `renderFromMarkdown()` を使用）。

#### 処理フロー

```
updateFromMarkdown()
  │
  ├─ 1. saveCursorState()
  │     カーソル位置を「ブロックインデックス + テキストオフセット」として保存
  │     例: 3番目のブロック（<p>）内の12文字目 → { blockIndex: 3, textOffset: 12 }
  │
  ├─ 2. markdownToHtmlFragment()
  │     新しいMarkdownからHTMLを生成し、一時的な<div>に格納
  │
  ├─ 3. ブロック単位diff
  │     既存のDOMブロック（p, h1, ul, pre, table...）と新しいブロックを1つずつ比較
  │     ├─ 同一ブロック → そのまま残す（DOMに触らない）
  │     ├─ 変更ブロック → 差し替え（ただし編集モードのコードブロック等は保護）
  │     ├─ 新規ブロック → 末尾に追加
  │     └─ 削除ブロック → DOMから除去
  │
  └─ 4. restoreCursorState()
        保存したブロックインデックス + テキストオフセットからカーソルを復元
        ブロック数が変わった場合は、最も近いブロックにフォールバック
```

#### 比較ロジック (blocksAreEqual())

```javascript
function blocksAreEqual(a, b) {
    if (a.tagName !== b.tagName) return false;                           // タグ名比較
    if (a.tagName === 'HR' && b.tagName === 'HR') return true;          // 水平線は常に同一
    if (a.getAttribute('data-lang') !== b.getAttribute('data-lang')) return false;  // 言語属性
    if (a.className !== b.className) return false;                       // クラス名
    return normalizeBlockHtml(a.innerHTML) === normalizeBlockHtml(b.innerHTML);     // 正規化後の内容比較
}
```

正規化では空白の違いや `contenteditable` 属性の差異を無視し、意味的な等価性のみを比較する。

#### 保護ブロック (isProtectedBlock())

以下のブロックは外部変更があっても差し替えない:
- 編集モード（`data-mode="edit"`）のコードブロック
- 編集モードのMermaidブロック

ユーザーが現在編集中のコードブロックが外部変更で突然書き換わることを防ぐ。

#### カーソル保存/復元の仕組み

**保存** (`saveCursorState()`):
1. カーソルがあるDOMノードから親を辿り、エディタ直下のブロック要素を特定
2. ブロックの先頭からカーソル位置までのテキスト長を計測（`Range.toString().length`）
3. `{ blockIndex: N, textOffset: M }` として保存

**復元** (`restoreCursorState()`):
1. 保存されたブロックインデックスの要素を取得（ブロック数が減っていれば最後のブロックにフォールバック）
2. テキストノードを先頭からウォークし、目標のテキストオフセットに到達したノードと位置を特定
3. `Range` を作成してカーソルを設定

**テキストオフセットによる復元が堅牢な理由:**
- DOMの構造が変わっても（例: `<strong>` の追加/削除）、テキストの位置は変わらないことが多い
- ブロック内のテキストが外部変更で書き換わった場合でも、オフセット範囲内なら最も近い位置にフォールバックする

#### 要件との対応

| 要件 | 対応 |
| --- | --- |
| **(1)** | `innerHTML` 全置換を行わない。変更のあったブロックだけを差し替える |
| **(4)** | `saveCursorState()` / `restoreCursorState()` でカーソル位置を復元する |

---

### Phase 2: isActivelyEditing — idle検知による外部変更反映制御

#### 対象ファイル
- `src/webview/editor.js`
- `src/editorProvider.ts`

#### 課題
従来の `document.hasFocus()` による判定は「フォーカスがある = 編集中」と等価だった。しかし実際には、フォーカスがあっても何も入力していない状態は「アイドル」であり、外部変更を反映すべき。

#### 解決策
「今まさにキー入力しているか」をリアルタイムに検知する `isActivelyEditing` 状態を導入。

#### 状態遷移

```
       キー入力/input発生
            │
            ▼
    isActivelyEditing = true ◄──── タイマーリセット（1.5秒）
            │
            │ 1.5秒間何も入力なし
            ▼
    isActivelyEditing = false
            │
            ▼
    溜まった外部変更を反映 (applyQueuedExternalChange)
```

#### markActivelyEditing() の呼び出しタイミング

| イベント | 呼び出し条件 |
| --- | --- |
| `keydown` | 矢印キー、修飾キー単体（Shift, Control, Alt, Meta）、CapsLock, Escape, Tab **以外**のすべてのキー |
| `input` | 常に呼び出し |

**除外キーの理由:**
- 矢印キー: ナビゲーションのみでDOMを変更しない
- 修飾キー単体: ショートカットの「押し始め」だけで編集とみなすべきではない
- Escape/Tab: UI操作であり、テキスト入力ではない

**Cmd+V（ペースト）等の複合キーの扱い:**
- `keydown` 時の `e.key` は `'v'` → 除外リストに入っていないので `markActivelyEditing()` が発火
- その後の `input` イベントでも `markActivelyEditing()` が発火
- → ペースト中も外部変更はキューされる

#### 外部変更の処理フロー

```
onDidChangeTextDocument 発火
    │
    ├─ isApplyingOwnEdit === true → スキップ（自分の編集）
    │
    └─ 外部変更 → Webviewに update メッセージ送信
                        │
                  Webview側で受信
                        │
                        ├─ isActivelyEditing === true
                        │     → queuedExternalContent に保存
                        │     → 1.5秒後（idle時）に applyQueuedExternalChange()
                        │
                        └─ isActivelyEditing === false
                              → 即座に updateFromMarkdown() で反映
```

#### blur時の強制idle

```javascript
editor.addEventListener('blur', function() {
    // 未送信の編集を即座にフラッシュ
    clearTimeout(syncTimeout);
    markdown = htmlToMarkdown();
    vscode.postMessage({ type: 'edit', content: markdown });

    // 強制的にidle状態に移行
    clearTimeout(editingIdleTimer);
    isActivelyEditing = false;
    vscode.postMessage({ type: 'editingStateChanged', editing: false });

    // 溜まった外部変更を反映
    applyQueuedExternalChange();
});
```

#### idle遷移時のpending sync flush

idle状態に遷移する直前に、未送信のdebouncedSyncを強制実行する。これにより、外部変更を反映する前に自分の編集が確実にVSCode Documentに反映される。

```javascript
editingIdleTimer = setTimeout(function() {
    // Flush any pending sync before going idle
    if (pendingSync) {
        clearTimeout(syncTimeout);
        markdown = htmlToMarkdown();
        notifyChangeImmediate();
        pendingSync = false;
    }

    isActivelyEditing = false;
    vscode.postMessage({ type: 'editingStateChanged', editing: false });
    applyQueuedExternalChange();
}, EDITING_IDLE_TIMEOUT);
```

#### editorProvider.ts の変更

```typescript
// Before (v0.195.245): フォーカスベース
let webviewHasFocus = false;
let missedExternalChange = false;

vscode.workspace.onDidChangeTextDocument(e => {
    if (webviewHasFocus) {
        // フォーカス中は全て無視、外部変更はトースト表示のみ
        missedExternalChange = true;
        return;
    }
    // Webviewに通知
});

// After (v0.195.246): idle検知ベース
let isActivelyEditing = false;
let isApplyingOwnEdit = false;

vscode.workspace.onDidChangeTextDocument(e => {
    if (isApplyingOwnEdit) return;  // 自分の編集はスキップ

    // 外部変更はWebviewに送信。Webview側でqueue/即時反映を判断
    webviewPanel.webview.postMessage({ type: 'update', content: ... });
});
```

**削除されたもの:**
- `missedExternalChange` フラグ — 不要に（Webview側でキューイング）
- `webviewBlur` 時の一括反映ロジック — 不要に（Phase 1の `updateFromMarkdown()` で随時反映）
- `scheduleEdit()` 内の `missedExternalChange` ガード — 不要に
- 外部変更検知時のトースト通知 — 不要に（自動反映されるため）

**追加されたもの:**
- `editingStateChanged` メッセージハンドラ — Webviewのidle状態を追跡

#### 要件との対応

| 要件 | 対応 |
| --- | --- |
| **(2)** | `isActivelyEditing === true` の間は外部変更をキューに溜める |
| **(3)** | フォーカスがあっても `isActivelyEditing === false`（1.5秒idle）なら即座に反映。blur時も強制的にidle化して反映 |

---

### Phase 3: FileWatcher改善 — VSCodeメッセージ抑制

#### 対象ファイル
- `src/editorProvider.ts`

#### 課題
外部ツール（git, AI, 別エディタ等）がファイルを直接変更した場合、以下の流れでVSCodeメッセージが表示される:

```
外部ツールがファイルを変更
    ↓
VSCode FileWatcher が検知
    ↓
FileWatcher が applyEdit() でTextDocumentを更新
    ↓
TextDocument の内容がファイルの内容と同期されるが、
applyEdit() は「未保存の変更」として扱われる
    ↓
VSCode が「保存されていません」マーカーを表示
    ↓
場合によっては「競合が発生しました」ダイアログも表示
```

#### 解決策
FileWatcherの処理を以下のように改善:

```
外部ファイル変更検知
    │
    ├─ ① isApplyingOwnEdit = true
    │     onDidChangeTextDocument でこの編集がスキップされる
    │
    ├─ ② applyEdit() でTextDocumentを更新
    │     VSCode Document の内容をファイルと同期
    │
    ├─ ③ isApplyingOwnEdit = false
    │
    ├─ ④ document.save()
    │     dirty状態をクリア → 「保存されていません」マーカーを除去
    │     ファイルの内容は既に最新なので、save()は実質的にno-op
    │
    └─ ⑤ Webviewに直接 update メッセージ送信
          ②で onDidChangeTextDocument が抑制されるため、
          Webviewへの通知を別途手動で行う
```

#### コード変更

```typescript
// Before (v0.195.245):
const fileChangeSubscription = fileWatcher.onDidChange(async (uri) => {
    // ... ファイル読み込み ...
    const edit = new vscode.WorkspaceEdit();
    edit.replace(document.uri, fullRange, newContent);
    await vscode.workspace.applyEdit(edit);
    // → onDidChangeTextDocument が発火し、そこからWebviewに通知
    // → dirty状態が残り、VSCodeメッセージが表示される
});

// After (v0.195.246):
const fileChangeSubscription = fileWatcher.onDidChange(async (uri) => {
    // ... ファイル読み込み ...
    isApplyingOwnEdit = true;  // ← ①
    const edit = new vscode.WorkspaceEdit();
    edit.replace(document.uri, fullRange, newContent);
    await vscode.workspace.applyEdit(edit);  // ← ②
    isApplyingOwnEdit = false;  // ← ③

    await document.save();  // ← ④ dirty状態をクリア

    // ← ⑤ Webviewに直接通知（onDidChangeTextDocumentは抑制済み）
    const content = convertImagePaths(newContent);
    webviewPanel.webview.postMessage({ type: 'update', content: content });
});
```

#### document.save() が安全な理由

`applyEdit()` でTextDocumentの内容をファイルの最新内容に更新した直後に `save()` を呼ぶ。この時点でTextDocumentの内容 = ファイルの内容なので、`save()` は実質的にno-op（何も書き込まない）。しかしVSCode内部のdirtyフラグはクリアされるため、「保存されていません」マーカーが消える。

#### 要件との対応

| 要件 | 対応 |
| --- | --- |
| **(5)** | `document.save()` でdirty状態をクリアし、VSCodeメッセージを抑制。`isApplyingOwnEdit` でバウンスバックを防止 |

---

## 変更されたファイル

| ファイル | 追加行 | 削除行 | 内容 |
| --- | --- | --- | --- |
| `src/webview/editor.js` | +312 | -10 | `updateFromMarkdown()`, カーソル保存/復元, `isActivelyEditing`, `markActivelyEditing()`, `applyQueuedExternalChange()`, blur/focus改善 |
| `src/editorProvider.ts` | +24 | -50 | `onDidChangeTextDocument` 簡素化, `editingStateChanged` ハンドラ, FileWatcher改善, `missedExternalChange` 削除 |
| `package.json` | +1 | -1 | バージョン 0.195.245 → 0.195.246 |

---

## 設計思想の転換

### Before (v0.195.245): フォーカスベース排他制御

```
判定: document.hasFocus() → true なら全ての外部変更を無視
更新: renderFromMarkdown() → innerHTML 全置換
結果: シンプルだが、フォーカス中は外部変更が一切反映されない
```

### After (v0.195.246): idle検知 + ブロックdiff

```
判定: isActivelyEditing → 入力中のみブロック、idle時は反映
更新: updateFromMarkdown() → ブロック単位diff、変更箇所のみ差し替え
結果: フォーカス中でもidle時は外部変更が反映される。カーソルは常に保持
```

### 比較表

| 観点 | v0.195.245 | v0.195.246 |
| --- | --- | --- |
| 自分の編集の判定 | `webviewHasFocus` フラグ | `isApplyingOwnEdit` フラグ |
| 外部変更の受入判定 | `document.hasFocus()`（全か無か） | `isActivelyEditing`（入力中のみブロック） |
| DOM更新方式 | `innerHTML` 全置換 | ブロック単位diff（変更箇所のみ） |
| カーソル保存 | なし | blockIndex + textOffset で保存/復元 |
| 外部変更の反映タイミング | blur時に一括 | idle時（1.5秒）に随時 |
| VSCodeメッセージ抑制 | なし | `document.save()` でdirty状態クリア |
| タイミング依存性 | イベント発火タイミングに依存しない | イベント発火タイミングに依存しない |

---

## テスト結果

| 結果 | 件数 |
| --- | --- |
| Pass | 428 |
| Fail | 3（既存バグ、本変更とは無関係） |
| Skip | 4 |

失敗した3件はいずれも変更前のコードでも同様に失敗することを確認済み:
- `samples/b.md` が存在しない（ENOENT）
- コードブロック末尾の空行保持テスト ×2

---

## 動作確認結果

| 確認項目 | 結果 |
| --- | --- |
| 自分の入力でカーソルジャンプしない | OK |
| 入力中は外部変更をブロック（idle後に反映） | OK |
| エディタにフォーカスあっても非入力時は外部変更反映 | OK |
| 外部変更時もカーソル位置を保持 | OK（範囲選択は解除されるが、カーソル位置は維持） |
| VSCodeの「保存されていません」等のメッセージが出ない | OK |
| 外部変更指示後にエディタで入力した内容は保持される | OK |
| 外部変更指示前に入力していた内容も保持される | OK |


---
# (補足) カーソルジャンプ問題の調査レポート

## 概要

VSCode拡張機能「Any Markdown」において、編集中にカーソルが意図しない位置にジャンプする問題が発生した。この問題はVSCodeでのみ発生し、CursorやKiroでは発生しなかった。本レポートでは、初期実装の同期メカニズムと、3つの修正コミットの変遷を詳細に分析する。

---

## 対象コミット

| コミット | 日時 | 概要 |
| --- | --- | --- |
| `b7c3615` / `699ea0d` | 2026-02-17 | 初期コミット（コード本体） |
| `940d7bc` | 2026-02-18 01:47 | Fix a reload bug that occurs only in VS Code |
| `9f9475a` | 2026-02-19 09:10 | Cursor jump issue investigation and fix |
| `8bba05d` | (後日) | Focus-based sync policy（最終解決策） |

---

## 1. 初期実装の状態 (699ea0d)

### 同期メカニズム

初期実装では、Webview ↔ VSCode Document 間の同期にシンプルなboolean型フラグを使用していた。

```
[Webview]                           [Extension]                        [VSCode Document]
   │                                     │                                    │
   │ ── edit message ──────────────────► │                                    │
   │    (markdown content)               │                                    │
   │                                     │ ── isUpdatingFromWebview = true ─► │
   │                                     │ ── applyEdit() ──────────────────► │
   │                                     │ ── isUpdatingFromWebview = false ─►│
   │                                     │                                    │
   │                                     │ ◄── onDidChangeTextDocument ──── │
   │                                     │    if (!isUpdatingFromWebview)      │
   │ ◄── update message ──────────────── │      → send update to webview      │
   │    renderFromMarkdown()              │                                    │
   │    (innerHTML全置換 → カーソル消失)    │                                    │
```

### 核心コード

#### editorProvider.ts — フラグによるガード

```typescript
let isUpdatingFromWebview = false;

// Webviewからの編集をドキュメントに反映
const applyPendingEdit = async () => {
    try {
        isUpdatingFromWebview = true;   // ← フラグON
        await vscode.workspace.applyEdit(edit);
    } finally {
        isUpdatingFromWebview = false;  // ← フラグOFF
    }
};

// ドキュメント変更時 → Webviewに通知
vscode.workspace.onDidChangeTextDocument(e => {
    if (!isUpdatingFromWebview) {       // ← フラグで判定
        webviewPanel.webview.postMessage({ type: 'update', content: ... });
    }
});
```

#### editor.js — update受信時の処理

```javascript
window.addEventListener('message', function(event) {
    if (message.type === 'update') {
        markdown = message.content;
        renderFromMarkdown();  // innerHTML全置換 → カーソルが消失
    }
});
```

### なぜCursor/Kiroでは問題が発生しなかったのか

**根本原因: **`onDidChangeTextDocument`** イベントの発火タイミングの違い**

| IDE | `applyEdit()` 後の `onDidChangeTextDocument` | フラグ状態 |
| --- | --- | --- |
| **Cursor / Kiro** | 同期的に発火、またはフラグが `true` の間に発火 | `isUpdatingFromWebview = true` → イベント抑制成功 |
| **VSCode** | **非同期的に発火**（`finally` ブロック後にマイクロタスクとして発火） | `isUpdatingFromWebview = false` → イベント抑制**失敗** |

VSCodeでは `applyEdit()` が返す Promise が resolve された後、`finally` ブロックでフラグが `false` に戻った**後に** `onDidChangeTextDocument` が発火する。そのため、フラグはすでに `false` であり、**自分自身が引き起こした変更を「外部変更」と誤認**してしまう。

```
Timeline (VSCode):
─────────────────────────────────────────────────────────────►
│ applyEdit()  │ await resolve │ finally: flag=false │ onDidChangeTextDocument fires │
                                                       ↑
                                                       フラグ = false なので
                                                       「外部変更」と判断
                                                       → update を Webview に送信
                                                       → renderFromMarkdown()
                                                       → カーソルが消失！
```

**結果として発生するバウンスバック・ループ:**

```
1. ユーザーが文字を入力
2. Webview → edit message → Extension
3. Extension → applyEdit() → VSCode Document 更新
4. VSCode → onDidChangeTextDocument 発火（フラグは既に false）
5. Extension → 「外部変更だ」と誤認 → update message → Webview
6. Webview → renderFromMarkdown() → innerHTML 全置換
7. カーソル位置が消失（先頭にリセット）
```

さらにVSCodeは `applyEdit()` 後に正規化イベント（末尾の改行追加など）を追加で発火することがあり、これもバウンスバックの原因となった。

---

## 2. 修正コミット #1: 940d7bc

**タイトル:** Fix a reload bug that occurs only in VS Code

### 導入された対策（5層防御）

| 層 | メカニズム | 目的 |
| --- | --- | --- |
| 1 | `lastContentFromWebview` | Webviewから送信されたコンテンツを記録し、`onDidChangeTextDocument` で同一コンテンツが来たらスキップ |
| 2 | `contentBeingApplied` | `applyEdit()` 実行中のコンテンツを追跡（`lastContentFromWebview` がすでに新しい値に更新されている場合のレースコンディション対策） |
| 3 | `pendingContent` + `editDebounceTimer` のキャンセル | 真の外部変更検出時に、古いWebview編集を破棄 |
| 4 | FileWatcher の役割分離 | FileWatcher は `applyEdit` のみ実行。Webviewへの通知は `onDidChangeTextDocument` に一本化 |
| 5 | `lastApplyEditTime` + 500msクールダウン | `applyEdit()` 後500ms以内の変更イベントを無視（VSCode正規化イベント対策） |

### editorProvider.ts の変更

```typescript
// 新しいガード変数
let lastContentFromWebview: string | null = null;    // 層1
let contentBeingApplied: string | null = null;        // 層2
let lastApplyEditTime = 0;                            // 層5

// onDidChangeTextDocument での判定
vscode.workspace.onDidChangeTextDocument(e => {
    const currentContent = document.getText();

    // 層1: Webviewから送信されたコンテンツと同一ならスキップ
    if (currentContent === lastContentFromWebview) return;

    // 層2: 現在applyEdit中のコンテンツと同一ならスキップ
    if (currentContent === contentBeingApplied) return;

    // 層5: applyEdit後500ms以内ならスキップ
    if (Date.now() - lastApplyEditTime < 500) return;

    // ここに到達 = 真の外部変更
    // 層3: 古いWebview編集をキャンセル
    pendingContent = null;
    clearTimeout(editDebounceTimer);

    // Webviewに通知
    webviewPanel.webview.postMessage({ type: 'update', content: ... });
});
```

### editor.js の変更

```javascript
// updateハンドラに内容比較ガードを追加
if (message.type === 'update') {
    if (message.content === markdown) {
        return;  // 内容が同一なら再描画しない
    }
    markdown = message.content;
    renderFromMarkdown();
}
```

### 問題点

- 500msクールダウンは雑すぎた（正当な外部変更が500ms以内に来ると無視される）
- コンテンツ比較はVSCodeの末尾空白正規化でずれる場合がある

---

## 3. 修正コミット #2: 9f9475a

**タイトル:** Cursor jump issue investigation and fix

### 2つの修正

#### 修正A: ガードロジックの改善 (editorProvider.ts)

500msクールダウン（層5）を廃止し、`trimEnd()` による内容比較に置き換え。

```typescript
// Before (940d7bc):
if (Date.now() - lastApplyEditTime < 500) return;

// After (9f9475a):
if (currentContent.trimEnd() === lastContentFromWebview?.trimEnd()) return;
```

**理由:** VSCodeは `applyEdit()` 後に末尾の改行を追加することがある。`trimEnd()` で末尾空白を無視することで、この正規化イベントを正確に検出できる。時間ベースの判定より信頼性が高い。

#### 修正B: Backspace時のカーソル位置修正 (editor.js)

リスト項目内でテキストを選択してBackspaceを押した時のカーソルジャンプを修正。

**Before:**
```javascript
// Backspace後、常にli要素の先頭にカーソルを移動
range.deleteContents();
// ... 常にカーソルをli先頭に再配置
```

**After:**
```javascript
range.deleteContents();

// テキストが残っているか確認
const hasDirectText = /* li内の直接テキストの有無を判定 */;

if (!hasDirectText) {
    // 空になった場合のみカーソルを再配置
    li.innerHTML = '<br>';
    setCursorToEnd(li);
} else {
    // テキストが残っている場合はカーソルをそのまま維持
    // (deleteContents後の自然な位置)
}
```

### UIの変更

このコミットにはツールバーのアイコン化（Lucide SVG導入）も含まれており、バグ修正だけでなくUI改善も行われた。

---

## 4. 修正コミット #3: 8bba05d

**タイトル:** Focus-based sync policy（最終解決策）

### 根本的な方針転換

これまでの「コンテンツ比較によるバウンスバック検出」から、**「フォーカスに基づく排他制御」** に方針を転換した。

### 設計思想

```
シンプルなルール:
  Webviewにフォーカスがある間 → onDidChangeTextDocument を完全無視
  Webviewからフォーカスが外れたら → 全ての変更を外部変更として処理
```

### 削除されたもの（全て不要に）

- `lastContentFromWebview` — コンテンツ比較ガード
- `contentBeingApplied` — レースコンディション対策
- `isApplyingEdit` フラグ — 同期的ガード
- `normalize()` 関数 — 内容比較用の正規化
- `recentSentEdits` Set — Webview側のバウンスバック検出
- `trackSentEdit()` 関数

### 追加されたもの

```typescript
// editorProvider.ts
let webviewHasFocus = false;

// Webviewからのフォーカス通知
case 'webviewFocus':
    webviewHasFocus = true;
    break;
case 'webviewBlur':
    webviewHasFocus = false;
    break;

// onDidChangeTextDocument
vscode.workspace.onDidChangeTextDocument(e => {
    if (webviewHasFocus) return;  // フォーカス中は全て無視
    // フォーカスがない = 外部変更 → Webviewに通知
});
```

```javascript
// editor.js
editor.addEventListener('focus', () => {
    vscode.postMessage({ type: 'webviewFocus' });
});

editor.addEventListener('blur', () => {
    // blur時に未送信の編集をフラッシュ
    flushPendingSync();
    vscode.postMessage({ type: 'webviewBlur' });
});

// updateハンドラ
if (message.type === 'update') {
    if (document.hasFocus()) return;  // フォーカスがあれば無視
    markdown = message.content;
    renderFromMarkdown();
}
```

### 外部変更検知の仕組み

フォーカスが外れている間に発生した変更は全て外部変更として処理される。ユーザーに対しては「ファイルが外部で変更されました。再読み込みしますか？」というトーストを表示する。

### なぜこれが最善策なのか

| 方式 | 問題点 |
| --- | --- |
| booleanフラグ (`isUpdatingFromWebview`) | VSCodeの非同期イベント発火でタイミングがずれる |
| コンテンツ比較 (`lastContentFromWebview`) | 末尾空白の正規化、レースコンディション |
| 時間ベース (500msクールダウン) | 雑すぎて正当な外部変更を無視する可能性 |
| **フォーカスベース** | **意味的に正しい。ユーザーが編集中なら外部変更は無視すべき。** |

---

## まとめ

### 問題の本質

| 項目 | 詳細 |
| --- | --- |
| **問題** | 編集中にカーソルが先頭にジャンプする |
| **原因** | `applyEdit()` が引き起こす `onDidChangeTextDocument` を外部変更と誤認し、`renderFromMarkdown()` でinnerHTMLを全置換 |
| **VSCodeだけで発生した理由** | VSCodeは `onDidChangeTextDocument` を非同期に発火するため、同期フラグが効かない |
| **Cursor/Kiroで発生しなかった理由** | これらのIDEはイベント発火タイミングが異なり、同期フラグで正しく抑制できた |

### 修正の変遷

```
699ea0d: boolean フラグ (isUpdatingFromWebview)
   ↓ VSCodeで破綻
940d7bc: 5層防御 (コンテンツ比較 + レースコンディション対策 + 500msクールダウン)
   ↓ 500msクールダウンが雑すぎる
9f9475a: ガード改善 (trimEnd比較) + Backspaceカーソル修正
   ↓ まだ複雑すぎる
8bba05d: フォーカスベース排他制御 (最終解決策)
```

最終的に、複雑なコンテンツ比較ロジックを全て廃止し、「フォーカスがある間は外部変更を無視する」というシンプルで意味的に正しいルールに落ち着いた。


# (補足) 同期アーキテクチャ リファクタリング計画

## 目的

以下の5つの要件を全て満たす同期メカニズムを実装する。

| # | 要件 | 現状 |
| --- | --- | --- |
| (1) | 入力中にinnerHTML全置換を発生させない（カーソルジャンプ禁止） | 実現済み（フォーカスベース） |
| (2) | 入力中に外部変更は受け入れない | 実現済み |
| (3) | 入力していない時は外部変更を受け入れる。フォーカス中でもidle状態なら反映する。溜まった変更はidle時に反映 | **未実現**（フォーカス中は一切反映しない） |
| (4) | 全置換でも部分置換でも、カーソルを飛ばさない | **未実現**（renderFromMarkdownはinnerHTML全置換） |
| (5) | VSCodeの「保存されていません」「競合」等のメッセージを出さない | **部分的に問題あり** |

## 実装の依存関係

```
(4) カーソル保護付きDOM更新
 ↑ 前提条件
(3) isActivelyEditing + idle時の外部変更反映
 ↑ 前提条件
(5) FileWatcher改善 + VSCodeメッセージ抑制
```

(4) が全ての土台。(4) なしに (3) を実装すると、idle時の外部変更反映でカーソルが飛ぶ。

---

## Phase 1: カーソル保護付きDOM更新 — 要件 (4)

### 1-1. 概要

現在の `renderFromMarkdown()` は `editor.innerHTML = html` で全置換するため、カーソル位置が消失する。これを「ブロック単位diff + カーソル保存/復元」に置き換える。

### 1-2. 対象ファイル

- `src/webview/editor.js` — `renderFromMarkdown()` 関数の改修、新関数追加

### 1-3. 新関数: updateFromMarkdown()

外部変更の反映専用関数。既存の `renderFromMarkdown()` は初期描画やソースモード切替時にそのまま使う。

```javascript
/**
 * 外部変更を反映するためのカーソル保護付きDOM更新
 * renderFromMarkdown() とは異なり、変更のないブロックを維持する
 */
function updateFromMarkdown() {
    // 1. カーソル位置を保存
    const cursorState = saveCursorState();

    // 2. 新しいHTMLを生成（テンポラリDOM）
    let markdownToRender = removeDirectivesFromMarkdown(markdown);
    const newHtml = markdownToHtmlFragment(markdownToRender);
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = newHtml || '<p><br></p>';

    // 3. ブロック単位でdiff/patch
    patchBlocks(editor, tempDiv);

    // 4. インタラクティブ要素の再セットアップ（変更されたブロックのみ）
    setupInteractiveElements();

    // 5. カーソル位置を復元
    restoreCursorState(cursorState);
}
```

### 1-4. ブロック単位diff: patchBlocks()

エディタ直下の子要素（`<p>`, `<h1>`, `<ul>`, `<pre>`, `<table>`, `<hr>`, `<blockquote>`, `<div class="mermaid-wrapper">` 等）をブロックとして扱い、変更のあったブロックのみ差し替える。

```javascript
/**
 * エディタの直下子要素を新しいDOMとブロック単位で比較し、差分のみ更新する
 */
function patchBlocks(editorEl, newContainer) {
    const oldBlocks = Array.from(editorEl.children);
    const newBlocks = Array.from(newContainer.children);

    const maxLen = Math.max(oldBlocks.length, newBlocks.length);

    for (let i = 0; i < maxLen; i++) {
        const oldBlock = oldBlocks[i];
        const newBlock = newBlocks[i];

        if (!oldBlock && newBlock) {
            // 新しいブロックが追加された
            editorEl.appendChild(newBlock.cloneNode(true));
        } else if (oldBlock && !newBlock) {
            // ブロックが削除された
            editorEl.removeChild(oldBlock);
        } else if (oldBlock && newBlock) {
            // 両方存在 → 内容が同じか比較
            if (!blocksAreEqual(oldBlock, newBlock)) {
                // コードブロックの編集モード状態を保護
                if (isProtectedBlock(oldBlock)) {
                    // 編集中のコードブロック/Mermaidは更新しない
                    continue;
                }
                // 差し替え
                const replacement = newBlock.cloneNode(true);
                editorEl.replaceChild(replacement, oldBlock);
            }
        }
    }
}
```

### 1-5. ブロック比較: blocksAreEqual()

```javascript
/**
 * 2つのブロック要素が意味的に同一かを判定
 * outerHTML比較ではなく、正規化した比較を行う
 */
function blocksAreEqual(a, b) {
    // タグ名が異なれば不一致
    if (a.tagName !== b.tagName) return false;

    // 属性の比較（data-lang, style.textAlign 等）
    if (a.getAttribute('data-lang') !== b.getAttribute('data-lang')) return false;

    // innerHTML の正規化比較
    // 空白の違い、属性の順序の違い等を吸収
    return normalizeBlockHtml(a.innerHTML) === normalizeBlockHtml(b.innerHTML);
}

function normalizeBlockHtml(html) {
    return html
        .replace(/\s+/g, ' ')          // 連続空白を統一
        .replace(/>\s+</g, '><')        // タグ間の空白を除去
        .trim();
}
```

### 1-6. 保護ブロック判定: isProtectedBlock()

```javascript
/**
 * 編集中のコードブロックやMermaidブロックは更新しない
 */
function isProtectedBlock(block) {
    // コードブロックが編集モード
    if (block.tagName === 'PRE' && block.getAttribute('data-mode') === 'edit') {
        return true;
    }
    // Mermaidブロックが編集モード
    if (block.classList?.contains('mermaid-wrapper') &&
        block.getAttribute('data-mode') === 'edit') {
        return true;
    }
    return false;
}
```

### 1-7. カーソル保存/復元

```javascript
/**
 * カーソル状態を保存
 * テキストオフセットではなく、ブロックインデックス + ブロック内テキストオフセットで保存
 */
function saveCursorState() {
    const sel = window.getSelection();
    if (!sel || !sel.rangeCount) return null;

    const range = sel.getRangeAt(0);
    const anchorNode = sel.anchorNode;

    // カーソルがどのブロック（エディタ直下の子要素）にあるか特定
    let block = anchorNode;
    while (block && block.parentNode !== editor) {
        block = block.parentNode;
    }
    if (!block) return null;

    const blockIndex = Array.from(editor.children).indexOf(block);
    if (blockIndex === -1) return null;

    // ブロック内でのテキストオフセットを計算
    const preRange = document.createRange();
    preRange.setStart(block, 0);
    preRange.setEnd(range.startContainer, range.startOffset);
    const textOffset = preRange.toString().length;

    return { blockIndex, textOffset };
}

/**
 * カーソル状態を復元
 */
function restoreCursorState(state) {
    if (!state) return;

    const blocks = Array.from(editor.children);
    // ブロックが削除されていたら最も近いブロックを使う
    const targetIndex = Math.min(state.blockIndex, blocks.length - 1);
    if (targetIndex < 0) return;

    const block = blocks[targetIndex];

    // ブロック内のテキストオフセット位置を探す
    const position = findPositionByTextOffset(block, state.textOffset);
    if (!position) return;

    const range = document.createRange();
    range.setStart(position.node, position.offset);
    range.collapse(true);

    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
}

/**
 * テキストオフセットからDOMノード内の位置を見つける
 */
function findPositionByTextOffset(root, targetOffset) {
    let currentOffset = 0;

    function walk(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            const len = node.textContent.length;
            if (currentOffset + len >= targetOffset) {
                return { node, offset: targetOffset - currentOffset };
            }
            currentOffset += len;
            return null;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.tagName === 'BR') {
                currentOffset += 1; // BRは1文字分
                if (currentOffset >= targetOffset) {
                    return { node: node.parentNode, offset: Array.from(node.parentNode.childNodes).indexOf(node) + 1 };
                }
                return null;
            }
            for (const child of node.childNodes) {
                const result = walk(child);
                if (result) return result;
            }
        }
        return null;
    }

    const result = walk(root);
    // 見つからなかった場合はブロック末尾に配置
    if (!result) {
        return { node: root, offset: root.childNodes.length };
    }
    return result;
}
```

### 1-8. 呼び出し箇所の変更

| 箇所 | 変更前 | 変更後 |
| --- | --- | --- |
| `update` メッセージハンドラ | `renderFromMarkdown()` | `updateFromMarkdown()` |
| `init()` | `renderFromMarkdown()` | `renderFromMarkdown()` (変更なし) |
| ソースモード切替 | `renderFromMarkdown()` | `renderFromMarkdown()` (変更なし) |

初期描画とモード切替は全置換でOK（カーソル位置の期待がない）。
外部変更の反映時のみ `updateFromMarkdown()` を使う。

### 1-9. テスト観点

| テストケース | 期待結果 |
| --- | --- |
| 段落内にカーソルを置いた状態で、別の段落が外部変更 | カーソル位置不変 |
| コードブロック編集モード中に外部変更 | コードブロックの編集モード維持、カーソル不変 |
| テーブルセル内にカーソルがある状態で、テーブル外が変更 | セル内カーソル不変 |
| カーソルのあるブロック自体が変更された場合 | 同一ブロック内の最も近い位置にカーソル復元 |
| ブロックが追加/削除された場合 | カーソルのあるブロックのインデックスが変わっても追従 |

---

## Phase 2: isActivelyEditing + idle時の外部変更反映 — 要件 (1)(2)(3)

### 2-1. 概要

現在の `webviewHasFocus` による判定を `isActivelyEditing` に変更する。フォーカスの有無ではなく、入力操作のアイドル時間で判定する。

### 2-2. 対象ファイル

- `src/webview/editor.js` — イベントハンドラ、メッセージ送信の変更
- `src/editorProvider.ts` — `webviewHasFocus` → `isActivelyEditing` の変更

### 2-3. 状態遷移

```
                      入力イベント
                     (input/keydown/compositionstart)
                          │
                          ▼
               ┌─────────────────────┐
               │ isActivelyEditing   │
               │      = true         │
               │                     │
               │ 外部変更をキューに   │
               │ 溜める               │
               └──────────┬──────────┘
                          │ 1.5秒間入力なし
                          │ + 未送信syncをフラッシュ
                          ▼
               ┌─────────────────────┐
               │ isActivelyEditing   │
               │      = false        │
               │                     │
               │ キューに溜まった    │
               │ 外部変更を反映      │
               │ (updateFromMarkdown)│
               └─────────────────────┘
```

### 2-4. Webview側の変更 (editor.js)

```javascript
// ===== 新しい状態管理 =====
let isActivelyEditing = false;
let editingIdleTimer = null;
let queuedExternalContent = null;  // 溜まった外部変更

const EDITING_IDLE_TIMEOUT = 1500; // 1.5秒

/**
 * 入力操作を検知してisActivelyEditingをtrueにする
 */
function markActivelyEditing() {
    const wasIdle = !isActivelyEditing;
    isActivelyEditing = true;

    if (wasIdle) {
        vscode.postMessage({ type: 'editingStateChanged', editing: true });
    }

    clearTimeout(editingIdleTimer);
    editingIdleTimer = setTimeout(() => {
        // 未送信の編集をフラッシュ
        if (pendingSync) {
            clearTimeout(syncTimeout);
            markdown = htmlToMarkdown();
            notifyChangeImmediate();
            pendingSync = false;
        }

        isActivelyEditing = false;
        vscode.postMessage({ type: 'editingStateChanged', editing: false });

        // 溜まった外部変更を反映
        if (queuedExternalContent !== null) {
            markdown = queuedExternalContent;
            queuedExternalContent = null;
            currentImageDir = extractImageDirFromMarkdown(markdown);
            if (isSourceMode) {
                sourceEditor.value = markdown;
            } else {
                updateFromMarkdown();  // Phase 1で実装したカーソル保護付き更新
            }
            updateOutline();
            updateWordCount();
            updateStatus();
        }
    }, EDITING_IDLE_TIMEOUT);
}

// ===== イベントリスナーの変更 =====

// 既存の input リスナーに追加
editor.addEventListener('input', function(e) {
    markActivelyEditing();  // ← 追加
    markAsEdited();
    debouncedSync();
});

// keydown にも追加（入力以外のキー操作も検知）
// ※ 既存の keydown ハンドラの先頭に追加
editor.addEventListener('keydown', function(e) {
    // 矢印キー、修飾キーのみの場合は除外
    if (!e.key.startsWith('Arrow') && !['Shift', 'Control', 'Alt', 'Meta'].includes(e.key)) {
        markActivelyEditing();  // ← 追加
    }
    // ... 既存の処理
});

// IME入力
editor.addEventListener('compositionstart', function() {
    markActivelyEditing();  // ← 追加
    // ... 既存の処理
});
```

### 2-5. updateメッセージハンドラの変更

```javascript
// 変更前:
if (document.hasFocus()) {
    return; // フォーカスがあれば全て無視
}

// 変更後:
if (isActivelyEditing) {
    // 入力中 → キューに溜める
    queuedExternalContent = incomingContent;
    logger.log('[Any MD] update queued: user is actively editing');
    return;
}
// idle状態 → 即座に反映（カーソル保護付き）
```

### 2-6. focus/blurハンドラの変更

```javascript
// 変更前: webviewFocus/webviewBlur メッセージを送信
// 変更後: editingStateChanged メッセージに統一

editor.addEventListener('focus', function() {
    // フォーカスだけでは editing 状態にしない
    // ただし、Extension側にフォーカス状態は通知する（参考情報として）
    vscode.postMessage({ type: 'webviewFocus' });
});

editor.addEventListener('blur', function() {
    // blurされたら確実にidle状態にする
    clearTimeout(editingIdleTimer);

    if (!isSourceMode && hasUserEdited) {
        clearTimeout(syncTimeout);
        markdown = htmlToMarkdown();
        vscode.postMessage({ type: 'edit', content: markdown });
    }

    isActivelyEditing = false;
    vscode.postMessage({ type: 'editingStateChanged', editing: false });
    vscode.postMessage({ type: 'webviewBlur' });

    // blurしたので溜まった外部変更を即座に反映
    if (queuedExternalContent !== null) {
        markdown = queuedExternalContent;
        queuedExternalContent = null;
        currentImageDir = extractImageDirFromMarkdown(markdown);
        if (isSourceMode) {
            sourceEditor.value = markdown;
        } else {
            updateFromMarkdown();
        }
        updateOutline();
        updateWordCount();
        updateStatus();
    }
});
```

### 2-7. Extension側の変更 (editorProvider.ts)

```typescript
// 変更前
let webviewHasFocus = false;

// 変更後
let webviewHasFocus = false;       // 参考情報として維持
let isActivelyEditing = false;     // 新規: 入力中かどうか

// onDidChangeTextDocument の変更
const changeDocumentSubscription = vscode.workspace.onDidChangeTextDocument(e => {
    if (e.document.uri.toString() !== document.uri.toString()) return;
    if (e.contentChanges.length === 0) return;

    if (isActivelyEditing) {
        // 入力中 → 外部変更を記録するが、Webviewには通知しない
        // （Webview側でキューに溜めるので、ここでは何もしなくてよい場合もある）
        if (!isApplyingOwnEdit) {
            missedExternalChange = true;
            // Webviewにキューイングを指示
            const currentContent = document.getText();
            const content = convertImagePaths(currentContent);
            webviewPanel.webview.postMessage({
                type: 'update',
                content: content
            });
            // ↑ Webview側で isActivelyEditing ならキューに入る
        }
        return;
    }

    // idle状態 → 外部変更を即座に反映
    if (!isApplyingOwnEdit) {
        const currentContent = document.getText();
        const content = convertImagePaths(currentContent);
        webviewPanel.webview.postMessage({
            type: 'update',
            content: content
        });
    }
});

// メッセージハンドラの変更
case 'editingStateChanged':
    isActivelyEditing = message.editing;
    break;

case 'webviewFocus':
    webviewHasFocus = true;
    missedExternalChange = false;
    break;

case 'webviewBlur':
    webviewHasFocus = false;
    // blurされたらidle確定
    isActivelyEditing = false;
    break;
```

### 2-8. テスト観点

| テストケース | 期待結果 |
| --- | --- |
| フォーカスあり + 入力中 + 外部変更 | 変更がキューに溜まり、反映されない |
| フォーカスあり + 1.5秒idle + 外部変更 | カーソル保護付きで即座に反映 |
| フォーカスあり + 入力中 → 1.5秒idle | 溜まった外部変更がカーソル保護付きで反映 |
| フォーカスなし + 外部変更 | カーソル保護付きで即座に反映 |
| blur時に溜まった外部変更あり | blur処理で反映 |

---

## Phase 3: VSCodeメッセージ抑制 — 要件 (5)

### 3-1. 概要

VSCodeが表示する以下のメッセージを抑制する:
- 「保存されていません」（ドット表示）
- 「競合が発生しました」
- 「すでに上書きされています」

### 3-2. 現在の問題点

1. **FileWatcherの **`applyEdit`: 外部ファイル変更をFileWatcherで検知し、`applyEdit()` でドキュメントを更新している。ドキュメントがdirtyな時にこれを行うと、VSCodeが競合を検出する可能性がある。

1. **ドキュメントのdirty状態**: Webviewからの編集で `applyEdit()` を呼ぶたびにドキュメントがdirtyになる。これは正常だが、外部変更もdirtyにしてしまう。

### 3-3. 対策A: FileWatcherの改善

```typescript
// 変更前: FileWatcherで applyEdit して onDidChangeTextDocument に任せる
// 変更後: FileWatcherは直接 Webview に通知する（applyEdit を通さない）

const fileChangeSubscription = fileWatcher.onDidChange(async (uri) => {
    if (uri.toString() !== document.uri.toString()) return;

    setTimeout(async () => {
        try {
            const fileContent = await vscode.workspace.fs.readFile(uri);
            const newContent = new TextDecoder().decode(fileContent);
            const currentDocContent = document.getText();

            if (newContent === currentDocContent) return; // 同一なら何もしない

            if (isActivelyEditing) {
                // 入力中 → Webviewにキューイングを指示
                missedExternalChange = true;
                const content = convertImagePaths(newContent);
                webviewPanel.webview.postMessage({
                    type: 'update',
                    content: content
                });
            } else {
                // idle → ドキュメントを更新してからWebviewに通知
                isApplyingOwnEdit = true;
                const edit = new vscode.WorkspaceEdit();
                const fullRange = new vscode.Range(
                    document.positionAt(0),
                    document.positionAt(currentDocContent.length)
                );
                edit.replace(document.uri, fullRange, newContent);
                await vscode.workspace.applyEdit(edit);
                // ドキュメントを即座に保存してdirty状態を解消
                await document.save();
                isApplyingOwnEdit = false;
            }
        } catch (error) {
            console.error('[Any MD] Error:', error);
            isApplyingOwnEdit = false;
        }
    }, 100);
});
```

### 3-4. 対策B: 外部変更時のdirty解消

外部ファイル変更を取り込んだ後、ドキュメントを即座に保存してdirty状態を解消する。これにより「保存されていません」表示を防ぐ。

```typescript
// 外部変更を取り込んだ後
await vscode.workspace.applyEdit(edit);
// dirty状態を解消（ファイルは既に最新なので保存しても副作用なし）
await document.save();
```

### 3-5. 対策C: 自分の編集のdirtyは正常

ユーザーがWebviewで編集した場合のdirty表示（ドット）は正常な動作であり、抑制しない。ユーザーが Ctrl+S で保存するまでdirtyであるべき。

### 3-6. テスト観点

| テストケース | 期待結果 |
| --- | --- |
| Webviewで編集中（dirty） + 外部ファイル変更 | 競合メッセージが出ない |
| 外部ファイル変更のみ | 「保存されていません」表示が出ない |
| ユーザー編集 → 保存 → 外部変更 | スムーズに反映、メッセージなし |

---

## 実装順序とマイルストーン

### Step 1: updateFromMarkdown() の実装

- `patchBlocks()`, `blocksAreEqual()`, `isProtectedBlock()` を実装
- `saveCursorState()`, `restoreCursorState()`, `findPositionByTextOffset()` を実装
- `update` メッセージハンドラで `renderFromMarkdown()` → `updateFromMarkdown()` に切替
- 既存テストが全てパスすることを確認

### Step 2: isActivelyEditing の導入

- `markActivelyEditing()`, idle検知, キューイングを実装
- Extension側に `editingStateChanged` メッセージを追加
- focus/blurハンドラの変更
- `onDidChangeTextDocument` の判定条件変更

### Step 3: FileWatcher改善

- 外部変更検知フローの変更
- dirty状態管理の改善
- VSCodeメッセージ抑制の確認

### Step 4: テスト + 微調整

- 全既存テストの実行
- 新規テストケースの追加
- idle timeout値の調整（1.5秒が適切か検証）
- エッジケースの確認と修正

---

## リスクと注意点

### ブロック比較の精度

`blocksAreEqual()` のHTML正規化が甘いと、変更がないブロックまで差し替えてしまう。逆に厳しすぎると、実際の変更を検出できない。`outerHTML` の完全一致ではなく、正規化した比較が必要。

### setupInteractiveElements の冪等性

`setupInteractiveElements()` が同じブロックに対して二重にイベントリスナーを付けないか確認が必要。現在はイベント委譲（event delegation）でない箇所があり、差し替えたブロックにのみ再セットアップするか、全体を再セットアップするかの判断が必要。

### コードブロック/Mermaidの特殊状態

編集モードのコードブロックやMermaidブロックが外部変更で壊されないよう、`isProtectedBlock()` で保護する。ただし、保護されたブロック自体が外部で変更された場合は、次にidle状態になった時かblur時に反映する必要がある。

### IME入力中の考慮

`compositionstart` で `markActivelyEditing()` を呼び、`compositionend` までは確実にediting状態を維持する。idle timerの1.5秒はIMEの変換操作中に切れない程度の長さが必要。

### idle timeout値

1.5秒は暫定値。短すぎると入力の合間に外部変更が反映されてちらつく。長すぎるとユーザーが「外部変更が反映されない」と感じる。1.0〜2.0秒の範囲で調整する。
