# Release Note: v0.195.320

## 概要

カスタムUndo/Redo機能を新規実装した。ブラウザネイティブのundo（Cmd+Z）を完全に置き換え、Markdownスナップショットベースの確実な状態復元を提供する。

---

## 課題

### ブラウザネイティブundoが壊れている

`contenteditable`のブラウザネイティブundoは、プログラムによるDOM操作（`innerHTML`代入、`replaceWith`、`appendChild`等）を行うとundo履歴が破壊される。

Any Markdownでは以下の多数の箇所でプログラムDOM操作を行っているため、ネイティブundoがほぼ機能しない：

| 操作カテゴリ | 代表的な関数 | DOM操作の例 |
| --- | --- | --- |
| 構造変更 | `renderFromMarkdown()` | `editor.innerHTML = ...` で全DOM再構築 |
| パターン変換 | `convertToHeading()`, `convertToList()` | `replaceWith()` で要素タグ変更 |
| リスト操作 | `indentListItem()`, `outdentListItem()` | `appendChild()`, `insertBefore()` でネスト変更 |
| モード切替 | `enterEditMode()`, `enterDisplayMode()` | `code.innerHTML = ...` でハイライト切替 |
| Backspace合流 | 各Backspaceハンドラ | `remove()`, `insertBefore()` で要素統合 |
| ペースト | `paste`ハンドラ | `renderFromMarkdown()` でブロック再構築 |
| ツールバー操作 | `applyInlineFormat()`, `insertTable()` | `replaceWith()`, `insertBefore()` |

### 具体的な再現手順

```
1. リストを作成（- item1 / - item2 / - item3）
2. item2をTabでネスト化
3. Cmd+Z を押す
→ 期待: item2がトップレベルに戻る
→ 実際: 何も起きない or 予期しない状態になる
```

特に異種リスト（ul + ol + task）がネストされている場合、undo後にリスト構造が完全に崩壊する。

---

## 原因の詳細分析

### ブラウザネイティブundoの仕組み

ブラウザの`contenteditable`のundoは、`UndoManager`（内部実装）がユーザーの直接入力イベント（`input`, `insertText`, `deleteContentBackward`等）を記録する仕組みで動作する。

### なぜ壊れるのか

ブラウザのundoスタックは**DOMミューテーション**を単位として記録する。プログラムによるDOM操作（JavaScriptから`innerHTML`, `replaceWith`, `appendChild`を呼ぶ）は以下の理由でundoスタックと整合しない：

1. **`innerHTML`代入**: 既存の全子ノードが破棄され、新しいノードツリーが生成される。undoスタック内の参照は破棄されたノードを指したままになるため、undoしても元に戻らない
2. **`replaceWith`/`appendChild`**: ノードがDOMツリーから切り離される。undoスタック内のエントリが参照するノードが存在しないため、undo実行時にエラーまたは無視される
3. **`execCommand`との混在**: `document.execCommand('insertLineBreak')`等はundoスタックに記録されるが、直後のプログラムDOM操作がスタックを無効化する

### Any Markdownでの発生パターン

```
[ユーザー入力] → [パターン検出] → [プログラムDOM操作] → [undoスタック破壊]

例: "# " + Space
1. ユーザーが"# "を入力 → undoスタックに記録される
2. Spaceでパターン検出 → <p>を<h1>にreplaceWith()
3. <p>ノードがDOMから消失 → undoスタック内の参照が無効化
4. Cmd+Z → 破壊されたスタックを復元しようとするが失敗
```

### 代替アプローチの検討

| アプローチ | 評価 | 却下理由 |
| --- | --- | --- |
| DOMスナップショット（innerHTML保存） | △ | HTMLが巨大になる。描画モード/編集モードのUI状態まで保存すると不整合が生じる |
| MutationObserver | × | DOM変更を逆再生するのは複雑で、renderFromMarkdown()のような全置換に対応できない |
| execCommandベースのundo拡張 | × | そもそもexecCommandが非推奨（Deprecatedスペック）で、将来的に利用不可 |
| **Markdownスナップショット** | **◎** | Markdownテキストは小さく、renderFromMarkdown()で確実にDOMを復元できる。カーソル位置も別途保存可能 |

---

## 設計

### ハイブリッドスナップショット戦略

2種類のスナップショットタイミングを使い分ける：

| 種類 | タイミング | 用途 |
| --- | --- | --- |
| **即時スナップショット** (`saveSnapshot()`) | 構造変更操作の**直前** | Backspace, Enter, Tab, Space, ペースト, ツールバー操作, Ctrl+Bなどのショートカット |
| **デバウンス付きスナップショット** (`saveSnapshotDebounced()`) | `input`イベント（500ms間隔） | 通常のテキスト入力（連続した文字入力を1つのundoステップにまとめる） |

### スナップショットの内容

```javascript
{
    markdown: string,    // その時点のMarkdownテキスト全体
    cursor: {
        blockIndex: number,  // エディタ内のブロック要素インデックス
        blockText: string,   // そのブロックのtextContent（テキストベースマッチング用）
        textOffset: number   // ブロック内のテキストオフセット位置
    }
}
```

### undo実行フロー

```
Cmd+Z 押下
│
├─► 1. pendingSyncをキャンセル（clearTimeout + pendingSync = false）
│       → undo前の不完全なsyncが走らないようにする
│
├─► 2. 現在の状態をredoStackにpush
│       → undoした後のredo用に保存
│
├─► 3. undoStackからpop
│
├─► 4. markdown変数を復元
│
├─► 5. renderFromMarkdown() でDOM全体を再構築
│       → Markdown→HTML変換→editor.innerHTML代入
│
├─► 6. restoreCursorState() でカーソル位置を復元
│       → テキストベースマッチングでブロックを特定
│       → textOffsetでブロック内の位置を特定
│
├─► 7. notifyChangeImmediate() でVS Codeドキュメントに反映
│
└─► 8. updateButtons() でツールバーボタンの有効/無効を更新
```

### カーソル復元の仕組み

#### 保存 (`saveCursorState`)

1. `window.getSelection()`でカーソル位置を取得
2. カーソルが含まれるエディタ直下のブロック要素を特定し、`blockIndex`を記録
3. そのブロックの`textContent`を`blockText`として記録（テキストベースマッチング用）
4. ブロック先頭からカーソル位置までのRangeを生成し、`preRange.toString().length`でテキストオフセットを計算

#### 復元 (`restoreCursorState`)

1. **テキストベースマッチング**: 保存時の`blockText`と一致するブロックを全ブロックから検索
   - 完全一致が1つ → そのブロックを使用
   - 完全一致が複数 → `blockIndex`に最も近いものを選択
   - 一致なし → `blockIndex`でフォールバック（挿入/削除でインデックスがずれた場合）
2. **テキストオフセット復元**: `findPositionByTextOffset()`でテキストノードを走査し、保存時のオフセット位置に対応するDOMノード+オフセットを特定
3. `Range.setStart()` + `Selection.addRange()`でカーソルを配置

**テキストベースマッチングを採用した理由**: `blockIndex`のみだと、undo時にブロック数が増減した場合にカーソルが別のブロックに飛ぶ。テキスト内容で照合することで、ブロックの追加/削除があっても正しいブロックにカーソルを復元できる。

### ネイティブundoの無効化

capture phaseの`keydown`リスナーで、`Cmd+Z` / `Cmd+Shift+Z` / `Ctrl+Y`の`preventDefault()`を実行。ブラウザのネイティブundo/redoを完全に抑止し、カスタム実装のみが動作する。

```
document.addEventListener('keydown', function(e) {
    var isMod = e.ctrlKey || e.metaKey;
    if (isMod && !isSourceMode && (e.key === 'z' || e.key === 'Z' || e.key === 'y')) {
        e.preventDefault();
    }
}, true); // capture phase
```

**capture phaseを使う理由**: エディタの`keydown`リスナーより先に実行される必要がある。バブリングフェーズだと、ブラウザのネイティブundoがエディタのkeydownハンドラより先に実行される可能性がある。

### スタック管理

| パラメータ | 値 | 理由 |
| --- | --- | --- |
| `MAX_STACK` | 200 | メモリ使用量と操作履歴の十分さのバランス。Markdownテキストは比較的小さいため200エントリでも数MB程度 |
| `TYPING_DEBOUNCE` | 500ms | 連続タイピング中のスナップショットを間引く。500ms以上入力が止まると次のスナップショットを取る |
| 重複排除 | `undoStack[last].markdown === state.markdown` | 同じ内容のスナップショットが連続で積まれるのを防止（例: Backspace直前にinputのdebounceが発火した場合） |
| redoスタッククリア | `saveSnapshot()`時 | 新しい操作が行われたらredoは無効化（一般的なundo/redoの動作） |

### _isUndoRedoガードフラグ

undo/redo実行中に`saveSnapshot()`が呼ばれるのを防止する。

```
undo()
├─► _isUndoRedo = true
├─► renderFromMarkdown()  → inputイベントが発火
│   └─► input handler → saveSnapshotDebounced() → _isUndoRedo が true なので何もしない
├─► restoreCursorState()
├─► notifyChangeImmediate()
└─► _isUndoRedo = false
```

`_isUndoRedo`が無いと、undo中の`renderFromMarkdown()`が`input`イベントを発火し、undo直後の状態がスナップショットとして保存されてしまう。結果、undo→undoが「1つ前に戻す→今の状態を保存→1つ前に戻す→今の状態を保存→...」の無限ループになる。

### 外部変更時のスタッククリア

VS Codeから`update`メッセージで外部変更が適用された場合、`undoManager.clear()`でundo/redoスタックを全消去する。外部変更後のundoは意味をなさない（外部の変更を含む状態をundoしても元に戻らない）ため。

---

## 実装

### 変更ファイル一覧

| ファイル | 変更内容 |
| --- | --- |
| `src/i18n/messages.ts` | `WebviewMessages`インターフェースに`undo`/`redo`プロパティ追加 |
| `src/i18n/locales/en.ts` | `undo: 'Undo (Ctrl+Z)'`, `redo: 'Redo (Ctrl+Shift+Z)'` |
| `src/i18n/locales/ja.ts` | `undo: '元に戻す (Ctrl+Z)'`, `redo: 'やり直す (Ctrl+Shift+Z)'` |
| `src/i18n/locales/zh-cn.ts` | `undo: '撤销 (Ctrl+Z)'`, `redo: '重做 (Ctrl+Shift+Z)'` |
| `src/i18n/locales/zh-tw.ts` | `undo: '復原 (Ctrl+Z)'`, `redo: '重做 (Ctrl+Shift+Z)'` |
| `src/i18n/locales/ko.ts` | `undo: '실행 취소 (Ctrl+Z)'`, `redo: '다시 실행 (Ctrl+Shift+Z)'` |
| `src/i18n/locales/es.ts` | `undo: 'Deshacer (Ctrl+Z)'`, `redo: 'Rehacer (Ctrl+Shift+Z)'` |
| `src/i18n/locales/fr.ts` | `undo: 'Annuler (Ctrl+Z)'`, `redo: 'Rétablir (Ctrl+Shift+Z)'` |
| `src/webviewContent.ts` | ツールバーHTMLに`history`グループ（undo/redoボタン）追加 |
| `src/webview/editor.js` | UndoManager本体 + 全フック（8箇所） |

### editor.js の変更詳細

#### 1. LUCIDE_ICONSにundo/redoアイコン追加（L24-26）

```javascript
'undo': '<svg ...><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>',
'redo': '<svg ...><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"/></svg>',
```

Lucide Iconsの`Undo2`/`Redo2`を使用。矢印の回転方向でundo（左回り）/redo（右回り）を直感的に表現。

#### 2. UndoManager IIFE（L388-479）

`init()`完了直後に定義。IIFEパターンで内部状態をカプセル化。

```javascript
var undoManager = (function() {
    var MAX_STACK = 200;
    var undoStack = [];
    var redoStack = [];
    var typingTimer = null;
    var TYPING_DEBOUNCE = 500;
    var _isUndoRedo = false;

    function capture() {
        return { markdown: markdown, cursor: saveCursorState() };
    }

    function saveSnapshot() {
        if (_isUndoRedo) return;
        var state = capture();
        // 重複排除: 直前のスナップショットと同じMarkdownなら保存しない
        if (undoStack.length > 0 && undoStack[undoStack.length - 1].markdown === state.markdown) return;
        undoStack.push(state);
        if (undoStack.length > MAX_STACK) undoStack.shift();
        redoStack.length = 0; // 新しい操作でredoスタッククリア
        updateButtons();
    }

    function saveSnapshotDebounced() {
        if (_isUndoRedo) return;
        if (typingTimer) return; // デバウンス中はスキップ
        saveSnapshot();
        typingTimer = setTimeout(function() { typingTimer = null; }, TYPING_DEBOUNCE);
    }

    function undo() { /* ... */ }
    function redo() { /* ... */ }
    function updateButtons() { /* ... */ }
    function clear() { /* ... */ }

    return {
        saveSnapshot, saveSnapshotDebounced,
        undo, redo, updateButtons, clear,
        get isUndoRedo() { return _isUndoRedo; }
    };
})();
```

#### 3. ネイティブundo無効化（L5727-5731）

既存のcapture-phase Tab keyリスナーに追加。

```javascript
// Disable browser native undo/redo in live preview mode
var isMod = e.ctrlKey || e.metaKey;
if (isMod && !isSourceMode && (e.key === 'z' || e.key === 'Z' || e.key === 'y')) {
    e.preventDefault();
}
```

#### 4. 即時スナップショット保存ポイント（6箇所）

各構造変更操作の**先頭**で`undoManager.saveSnapshot()`を呼び出し、操作前の状態を保存する。

| キー | 挿入位置 | 理由 |
| --- | --- | --- |
| Backspace | `if (e.key === 'Backspace')` の直後 | リスト合流、要素削除、ブロック統合等の構造変更 |
| Enter | `if (e.key === 'Enter')` の直後 | 新段落作成、リスト分割、パターン変換トリガー |
| Space | `if (e.key === ' ')` の直後 | インラインパターン変換（`**bold**` + Space → `<strong>`） |
| Tab | `if (e.key === 'Tab')` の直後 | リストインデント/アウトデント |
| Paste | `editor.addEventListener('paste', ...)` の先頭 | ブロックペーストでの全DOM再構築 |
| ツールバーclick | `switch (action)` の直前 | 見出し変換、リスト作成、テーブル挿入等 |

#### 5. デバウンス付きスナップショット（1箇所）

```javascript
// input handler
editor.addEventListener('input', function(e) {
    if (isSourceMode) return;
    markActivelyEditing();
    markAsEdited();
    undoManager.saveSnapshotDebounced(); // ← 追加
    // ...
});
```

通常のテキスト入力は500ms間隔でスナップショットを取る。「Hello World」と入力した場合、500msの切れ目に応じて1〜3個のundoステップになる。

#### 6. ショートカットハンドラ（L10711-10730）

```javascript
// Undo (Ctrl+Z / Cmd+Z)
if (isMod && !e.shiftKey && e.key === 'z') {
    e.preventDefault();
    e.stopPropagation();
    if (!isSourceMode) undoManager.undo();
    return;
}

// Redo (Ctrl+Shift+Z / Cmd+Shift+Z / Ctrl+Y)
if (isMod && ((e.shiftKey && e.key.toLowerCase() === 'z') || (!e.shiftKey && e.key === 'y'))) {
    e.preventDefault();
    e.stopPropagation();
    if (!isSourceMode) undoManager.redo();
    return;
}

// Save snapshot before structural shortcuts
// (Ctrl+B, Ctrl+I, Ctrl+1-6, Ctrl+Shift+U/O/X/Q/K 等)
if (isMod && !isSourceMode && /* 除外リスト */) {
    undoManager.saveSnapshot();
}
```

ショートカット除外リスト: `s`(保存), `f`(検索), `h`(置換), `l`(チャット送信), `a`(全選択), `z`/`Z`/`y`(undo/redo), `v`(ペースト), `c`(コピー), `x`(カット)

#### 7. ツールバーundo/redoボタンハンドラ（L10332-10338）

```javascript
switch (action) {
    case 'undo':
        undoManager.undo();
        break;
    case 'redo':
        undoManager.redo();
        break;
    // ... 既存のcase ...
}
```

ツールバーのundo/redoボタンにはスナップショット保存をスキップするガード付き：

```javascript
if (action !== 'undo' && action !== 'redo' && action !== 'source' && action !== 'openOutline') {
    undoManager.saveSnapshot();
}
```

#### 8. 外部変更時のスタッククリア（L11538）

```javascript
// update message handler
updateOutline();
updateWordCount();
updateStatus();
undoManager.clear(); // ← 追加
```

#### 9. ボタンの有効/無効表示

```javascript
function updateButtons() {
    var u = document.querySelector('[data-action="undo"]');
    var r = document.querySelector('[data-action="redo"]');
    if (u) { u.disabled = !undoStack.length; u.style.opacity = undoStack.length ? '1' : '0.3'; }
    if (r) { r.disabled = !redoStack.length; r.style.opacity = redoStack.length ? '1' : '0.3'; }
}
```

スタックが空の場合、ボタンを`disabled`にしてopacityを0.3に下げる。操作可能な時は1.0。

### ツールバーレイアウト

```
[Outline] | [↶ Undo][↷ Redo] | [B][I][S][</>] | [H1]...[H6] | [•][1.][☐] | ...
           ^^^^^^^^^^^^^^^^
           新規追加（historyグループ）
```

Outlineボタンの右、インライン書式グループの左に配置。

---

## テスト結果

- **478 passed** / 1 failed（`samples/b.md`不在、既存の問題）/ 4 skipped
- undo/redo実装による既存テストへの影響なし

---

## 制限事項・今後の課題

| 項目 | 状況 |
| --- | --- |
| ソースモードでのundo | 未対応（ブラウザのtextareaネイティブundoがそのまま動作） |
| 画像挿入のundo | Markdownテキスト上は復元されるが、保存された画像ファイルは削除されない |
| 大規模ドキュメント | MAX_STACK=200でMarkdownテキストを保持するため、非常に大きなファイルではメモリ使用量が増加する可能性 |
| undo/redoのテスト自動化 | Playwrightテストでの検証は未実装（手動検証済み） |
